// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"project/internal/model"
)

func newLogo(db *gorm.DB, opts ...gen.DOOption) logo {
	_logo := logo{}

	_logo.logoDo.UseDB(db, opts...)
	_logo.logoDo.UseModel(&model.Logo{})

	tableName := _logo.logoDo.TableName()
	_logo.ALL = field.NewAsterisk(tableName)
	_logo.ID = field.NewString(tableName, "id")
	_logo.SystemName = field.NewString(tableName, "system_name")
	_logo.LogoCache = field.NewString(tableName, "logo_cache")
	_logo.LogoBackground = field.NewString(tableName, "logo_background")
	_logo.LogoLoading = field.NewString(tableName, "logo_loading")
	_logo.HomeBackground = field.NewString(tableName, "home_background")
	_logo.Remark = field.NewString(tableName, "remark")

	_logo.fillFieldMap()

	return _logo
}

type logo struct {
	logoDo

	ALL            field.Asterisk
	ID             field.String // Id
	SystemName     field.String // 系统名称
	LogoCache      field.String // 站标Logo
	LogoBackground field.String // 加载页面Logo
	LogoLoading    field.String // 加载页面Logo
	HomeBackground field.String // 首页背景
	Remark         field.String

	fieldMap map[string]field.Expr
}

func (l logo) Table(newTableName string) *logo {
	l.logoDo.UseTable(newTableName)
	return l.updateTableName(newTableName)
}

func (l logo) As(alias string) *logo {
	l.logoDo.DO = *(l.logoDo.As(alias).(*gen.DO))
	return l.updateTableName(alias)
}

func (l *logo) updateTableName(table string) *logo {
	l.ALL = field.NewAsterisk(table)
	l.ID = field.NewString(table, "id")
	l.SystemName = field.NewString(table, "system_name")
	l.LogoCache = field.NewString(table, "logo_cache")
	l.LogoBackground = field.NewString(table, "logo_background")
	l.LogoLoading = field.NewString(table, "logo_loading")
	l.HomeBackground = field.NewString(table, "home_background")
	l.Remark = field.NewString(table, "remark")

	l.fillFieldMap()

	return l
}

func (l *logo) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := l.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (l *logo) fillFieldMap() {
	l.fieldMap = make(map[string]field.Expr, 7)
	l.fieldMap["id"] = l.ID
	l.fieldMap["system_name"] = l.SystemName
	l.fieldMap["logo_cache"] = l.LogoCache
	l.fieldMap["logo_background"] = l.LogoBackground
	l.fieldMap["logo_loading"] = l.LogoLoading
	l.fieldMap["home_background"] = l.HomeBackground
	l.fieldMap["remark"] = l.Remark
}

func (l logo) clone(db *gorm.DB) logo {
	l.logoDo.ReplaceConnPool(db.Statement.ConnPool)
	return l
}

func (l logo) replaceDB(db *gorm.DB) logo {
	l.logoDo.ReplaceDB(db)
	return l
}

type logoDo struct{ gen.DO }

type ILogoDo interface {
	gen.SubQuery
	Debug() ILogoDo
	WithContext(ctx context.Context) ILogoDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ILogoDo
	WriteDB() ILogoDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ILogoDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ILogoDo
	Not(conds ...gen.Condition) ILogoDo
	Or(conds ...gen.Condition) ILogoDo
	Select(conds ...field.Expr) ILogoDo
	Where(conds ...gen.Condition) ILogoDo
	Order(conds ...field.Expr) ILogoDo
	Distinct(cols ...field.Expr) ILogoDo
	Omit(cols ...field.Expr) ILogoDo
	Join(table schema.Tabler, on ...field.Expr) ILogoDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ILogoDo
	RightJoin(table schema.Tabler, on ...field.Expr) ILogoDo
	Group(cols ...field.Expr) ILogoDo
	Having(conds ...gen.Condition) ILogoDo
	Limit(limit int) ILogoDo
	Offset(offset int) ILogoDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ILogoDo
	Unscoped() ILogoDo
	Create(values ...*model.Logo) error
	CreateInBatches(values []*model.Logo, batchSize int) error
	Save(values ...*model.Logo) error
	First() (*model.Logo, error)
	Take() (*model.Logo, error)
	Last() (*model.Logo, error)
	Find() ([]*model.Logo, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Logo, err error)
	FindInBatches(result *[]*model.Logo, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.Logo) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ILogoDo
	Assign(attrs ...field.AssignExpr) ILogoDo
	Joins(fields ...field.RelationField) ILogoDo
	Preload(fields ...field.RelationField) ILogoDo
	FirstOrInit() (*model.Logo, error)
	FirstOrCreate() (*model.Logo, error)
	FindByPage(offset int, limit int) (result []*model.Logo, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ILogoDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (l logoDo) Debug() ILogoDo {
	return l.withDO(l.DO.Debug())
}

func (l logoDo) WithContext(ctx context.Context) ILogoDo {
	return l.withDO(l.DO.WithContext(ctx))
}

func (l logoDo) ReadDB() ILogoDo {
	return l.Clauses(dbresolver.Read)
}

func (l logoDo) WriteDB() ILogoDo {
	return l.Clauses(dbresolver.Write)
}

func (l logoDo) Session(config *gorm.Session) ILogoDo {
	return l.withDO(l.DO.Session(config))
}

func (l logoDo) Clauses(conds ...clause.Expression) ILogoDo {
	return l.withDO(l.DO.Clauses(conds...))
}

func (l logoDo) Returning(value interface{}, columns ...string) ILogoDo {
	return l.withDO(l.DO.Returning(value, columns...))
}

func (l logoDo) Not(conds ...gen.Condition) ILogoDo {
	return l.withDO(l.DO.Not(conds...))
}

func (l logoDo) Or(conds ...gen.Condition) ILogoDo {
	return l.withDO(l.DO.Or(conds...))
}

func (l logoDo) Select(conds ...field.Expr) ILogoDo {
	return l.withDO(l.DO.Select(conds...))
}

func (l logoDo) Where(conds ...gen.Condition) ILogoDo {
	return l.withDO(l.DO.Where(conds...))
}

func (l logoDo) Order(conds ...field.Expr) ILogoDo {
	return l.withDO(l.DO.Order(conds...))
}

func (l logoDo) Distinct(cols ...field.Expr) ILogoDo {
	return l.withDO(l.DO.Distinct(cols...))
}

func (l logoDo) Omit(cols ...field.Expr) ILogoDo {
	return l.withDO(l.DO.Omit(cols...))
}

func (l logoDo) Join(table schema.Tabler, on ...field.Expr) ILogoDo {
	return l.withDO(l.DO.Join(table, on...))
}

func (l logoDo) LeftJoin(table schema.Tabler, on ...field.Expr) ILogoDo {
	return l.withDO(l.DO.LeftJoin(table, on...))
}

func (l logoDo) RightJoin(table schema.Tabler, on ...field.Expr) ILogoDo {
	return l.withDO(l.DO.RightJoin(table, on...))
}

func (l logoDo) Group(cols ...field.Expr) ILogoDo {
	return l.withDO(l.DO.Group(cols...))
}

func (l logoDo) Having(conds ...gen.Condition) ILogoDo {
	return l.withDO(l.DO.Having(conds...))
}

func (l logoDo) Limit(limit int) ILogoDo {
	return l.withDO(l.DO.Limit(limit))
}

func (l logoDo) Offset(offset int) ILogoDo {
	return l.withDO(l.DO.Offset(offset))
}

func (l logoDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ILogoDo {
	return l.withDO(l.DO.Scopes(funcs...))
}

func (l logoDo) Unscoped() ILogoDo {
	return l.withDO(l.DO.Unscoped())
}

func (l logoDo) Create(values ...*model.Logo) error {
	if len(values) == 0 {
		return nil
	}
	return l.DO.Create(values)
}

func (l logoDo) CreateInBatches(values []*model.Logo, batchSize int) error {
	return l.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (l logoDo) Save(values ...*model.Logo) error {
	if len(values) == 0 {
		return nil
	}
	return l.DO.Save(values)
}

func (l logoDo) First() (*model.Logo, error) {
	if result, err := l.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Logo), nil
	}
}

func (l logoDo) Take() (*model.Logo, error) {
	if result, err := l.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Logo), nil
	}
}

func (l logoDo) Last() (*model.Logo, error) {
	if result, err := l.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Logo), nil
	}
}

func (l logoDo) Find() ([]*model.Logo, error) {
	result, err := l.DO.Find()
	return result.([]*model.Logo), err
}

func (l logoDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Logo, err error) {
	buf := make([]*model.Logo, 0, batchSize)
	err = l.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (l logoDo) FindInBatches(result *[]*model.Logo, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return l.DO.FindInBatches(result, batchSize, fc)
}

func (l logoDo) Attrs(attrs ...field.AssignExpr) ILogoDo {
	return l.withDO(l.DO.Attrs(attrs...))
}

func (l logoDo) Assign(attrs ...field.AssignExpr) ILogoDo {
	return l.withDO(l.DO.Assign(attrs...))
}

func (l logoDo) Joins(fields ...field.RelationField) ILogoDo {
	for _, _f := range fields {
		l = *l.withDO(l.DO.Joins(_f))
	}
	return &l
}

func (l logoDo) Preload(fields ...field.RelationField) ILogoDo {
	for _, _f := range fields {
		l = *l.withDO(l.DO.Preload(_f))
	}
	return &l
}

func (l logoDo) FirstOrInit() (*model.Logo, error) {
	if result, err := l.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Logo), nil
	}
}

func (l logoDo) FirstOrCreate() (*model.Logo, error) {
	if result, err := l.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Logo), nil
	}
}

func (l logoDo) FindByPage(offset int, limit int) (result []*model.Logo, count int64, err error) {
	result, err = l.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = l.Offset(-1).Limit(-1).Count()
	return
}

func (l logoDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = l.Count()
	if err != nil {
		return
	}

	err = l.Offset(offset).Limit(limit).Scan(result)
	return
}

func (l logoDo) Scan(result interface{}) (err error) {
	return l.DO.Scan(result)
}

func (l logoDo) Delete(models ...*model.Logo) (result gen.ResultInfo, err error) {
	return l.DO.Delete(models)
}

func (l *logoDo) withDO(do gen.Dao) *logoDo {
	l.DO = *do.(*gen.DO)
	return l
}
